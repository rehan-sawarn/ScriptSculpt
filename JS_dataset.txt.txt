name   newText
       Basics
       JavaScript borrows most of its syntax from Java, C, and C++, but it has also been influenced by Awk, Perl, and Python.
       JavaScript is case-sensitive and uses the Unicode character set. For example, the word Früh (which means "early" in German) could be used as a variable name.
       JS
       const Früh = "foobar";
       But, the variable früh is not the same as Früh because JavaScript is case-sensitive.
       In JavaScript, instructions are called statements and are separated by semicolons (;).
       A semicolon is not necessary after a statement if it is written on its own line. But if more than one statement on a line is desired, then they must be separated by semicolons.
       Note: ECMAScript also has rules for automatic insertion of semicolons (ASI) to end statements. (For more information, see the detailed reference about JavaScript's lexical grammar.)
       It is considered best practice, however, to always write a semicolon after a statement, even when it is not strictly needed. This practice reduces the chances of bugs getting into the code.
       The source text of JavaScript script gets scanned from left to right, and is converted into a sequence of input elements which are tokens, control characters, line terminators, comments, or whitespace. (Spaces, tabs, and newlin	characters are considered whitespace.)
       Comments
       The syntax of comments is the same as in C++ and in many other languages:
       JS
       // a one line comment
       /* this is a longer,
        * multi-line comment
        */
       You can't nest block comments. This often happens when you accidentally include a */ sequence in your comment, which will terminate the comment.
       JS
       /* You can't, however, /* nest comments */ SyntaxError */
       In this case, you need to break up the */ pattern. For example, by inserting a backslash:
       JS
       /* You can /* nest comments *\/ by escaping slashes */
       Comments behave like whitespace, and are discarded during script execution.
       Note: You might also see a third type of comment syntax at the start of some JavaScript files, which looks something like this: #!/usr/bin/env node.
       This is called hashbang comment syntax, and is a special comment used to specify the path to a particular JavaScript engine that should execute the script. See Hashbang comments for more details.
       Declarations
       JavaScript has three kinds of variable declarations.
       var
       Declares a variable, optionally initializing it to a value.
       let
       Declares a block-scoped, local variable, optionally initializing it to a value.
       const
       Declares a block-scoped, read-only named constant.
       Variables
       You use variables as symbolic names for values in your application. The names of variables, called identifiers, conform to certain rules.
       A JavaScript identifier usually starts with a letter, underscore (_), or dollar sign ($). Subsequent characters can also be digits (0 – 9). Because JavaScript is case sensitive, letters include the characters A through Z 	(uppercase) as well as a through z (lowercase).
       You can use most Unicode letters such as å and ü in identifiers. (For more details, see the lexical grammar reference.) You can also use Unicode escape sequences to represent characters in identifiers.
       Some examples of legal names are Number_hits, temp99, $credit, and _name.
       Declaring variables
       You can declare a variable in two ways:
       With the keyword var. For example, var x = 42. This syntax can be used to declare both local and global variables, depending on the execution context.
       With the keyword const or let. For example, let y = 13. This syntax can be used to declare a block-scope local variable. (See Variable scope below.)
       You can declare variables to unpack values using the destructuring assignment syntax. For example, const { bar } = foo. This will create a variable named bar and assign to it the value corresponding to the key of the same name 	from our object foo.
       Variables should always be declared before they are used. JavaScript used to allow assigning to undeclared variables, which creates an undeclared global variable. This is an error in strict mode and should be avoided altogether.
       Declaration and initialization
       In a statement like let x = 42, the let x part is called a declaration, and the = 42 part is called an initializer. The declaration allows the variable to be accessed later in code without throwing a ReferenceError, while the 	initializer assigns a value to the variable. In var and let declarations, the initializer is optional. If a variable is declared without an initializer, it is assigned the value undefined.
       JS
       let x;
       console.log(x); // logs "undefined"
       In essence, let x = 42 is equivalent to let x; x = 42.
       const declarations always need an initializer, because they forbid any kind of assignment after declaration, and implicitly initializing it with undefined is likely a programmer mistake.
       JS


Loops offer a quick and easy way to do something repeatedly. This chapter of the JavaScript Guide introduces the different iteration statements available to JavaScript.

You can think of a loop as a computerized version of the game where you tell someone to take X steps in one direction, then Y steps in another. For example, the idea "Go five steps to the east" could be expressed this way as a loop:

for (let step = 0; step < 5; step++) {
  // Runs 5 times, with values of step 0 through 4.
  console.log("Walking east one step");
}

There are many different kinds of loops, but they all essentially do the same thing: they repeat an action some number of times. (Note that it's possible that number could be zero!)

The statements for loops provided in JavaScript are:

- `for` statement
- `do...while` statement
- `while` statement
- `labeled` statement
- `break` statement
- `continue` statement
- `for...in` statement
- `for...of` statement

### `for` statement

A `for` loop repeats until a specified condition evaluates to false. The JavaScript `for` loop is similar to the Java and C `for` loop.

A `for` statement looks as follows:

for (initialization; condition; afterthought) {
  statement
}

When a `for` loop executes, the following occurs:

1. The initializing expression `initialization`, if any, is executed. This expression usually initializes one or more loop counters, but the syntax allows an expression of any degree of complexity. This expression can also declare variables.
2. The condition expression is evaluated. If the value of `condition` is true, the loop statements execute. Otherwise, the `for` loop terminates. (If the condition expression is omitted entirely, the condition is assumed to be true.)
3. The statement executes. To execute multiple statements, use a block statement (`{}`) to group those statements.
4. If present, the update expression `afterthought` is executed.
5. Control returns to Step 2.

**Example:**

In the example below, the function contains a `for` statement that counts the number of selected options in a scrolling list (`<select>` element that allows multiple selections).

<form name="selectForm">
  <label for="musicTypes">Choose some music types, then click the button below:</label>
  <select id="musicTypes" name="musicTypes" multiple>
    <option selected>R&B</option>
    <option>Jazz</option>
    <option>Blues</option>
    <option>New Age</option>
    <option>Classical</option>
    <option>Opera</option>
  </select>
  <button id="btn" type="button">How many are selected?</button>
</form>

<script>
function countSelected(selectObject) {
  let numberSelected = 0;
  for (let i = 0; i < selectObject.options.length; i++) {
    if (selectObject.options[i].selected) {
      numberSelected++;
    }
  }
  return numberSelected;
}

const btn = document.getElementById("btn");

btn.addEventListener("click", () => {
  const musicTypes = document.selectForm.musicTypes;
  console.log(`You have selected ${countSelected(musicTypes)} option(s).`);
});
</script>
```

### `do...while` statement

The `do...while` statement repeats until a specified condition evaluates to false.

A `do...while` statement looks as follows:

do {
  statement
} while (condition);

The `statement` is always executed once before the condition is checked. (To execute multiple statements, use a block statement (`{}`) to group those statements.)

If `condition` is true, the `statement` executes again. At the end of every execution, the condition is checked. When the condition is false, execution stops, and control passes to the statement following `do...while`.

**Example:**

In the following example, the `do` loop iterates at least once and reiterates until `i` is no longer less than 5.

let i = 0;
do {
  i += 1;
  console.log(i);
} while (i < 5);

### `while` statement

A `while` statement executes its statements as long as a specified condition evaluates to true. A `while` statement looks as follows:

while (condition) {
  statement
}

If the condition becomes false, `statement` within the loop stops executing, and control passes to the statement following the loop.

The condition test occurs before `statement` in the loop is executed. If the condition returns true, `statement` is executed, and the condition is tested again. If the condition returns false, execution stops, and control is passed to the statement following `while`.

**Example 1:**

The following `while` loop iterates as long as `n` is less than 3:

let n = 0;
let x = 0;
while (n < 3) {
  n++;
  x += n;
}

// After the first pass: n = 1 and x = 1
// After the second pass: n = 2 and x = 3
// After the third pass: n = 3 and x = 6
// After completing the third pass, the condition n < 3 is no longer true, so the loop terminates.

**Example 2:**

Avoid infinite loops. Make sure the condition in a loop eventually becomes false—otherwise, the loop will never terminate! The statements in the following `while` loop execute forever because the condition never becomes false:

// Infinite loops are bad!
while (true) {
  console.log("Hello, world!");
}

### `labeled` statement

A label provides a statement with an identifier that lets you refer to it elsewhere in your program. For example, you can use a label to identify a loop, and then use the `break` or `continue` statements to indicate whether a program should interrupt the loop or continue its execution.

The syntax of the labeled statement looks like the following:

label:
  statement

The value of `label` may be any JavaScript identifier that is not a reserved word. The statement that you identify with a label may be any statement. For examples of using labeled statements, see the examples of `break` and `continue` below.

### `break` statement

Use the `break` statement to terminate a loop, switch, or in conjunction with a labeled statement.

When you use `break` without a label, it terminates the innermost enclosing `while`, `do-while`, `for`, or `switch` immediately and transfers control to the following statement. When you use `break` with a label, it terminates the specified labeled statement.

The syntax of the `break` statement looks like this:

break;
break label;

The first form of the syntax terminates the innermost enclosing loop or switch. The second form of the syntax terminates the specified enclosing labeled statement.

**Example 1:

**

The following example iterates through the elements in an array until it finds the index of an element whose value is `theValue`:

for (let i = 0; i < a.length; i++) {
  if (a[i] === theValue) {
    break;
  }
}

**Example 2: Breaking to a label**

let x = 0;
let z = 0;
labelCancelLoops: while (true) {
  console.log("Outer loops:", x);
  x += 1;
  z = 1;
  while (true) {
    console.log("Inner loops:", z);
    z += 1;
    if (z === 10 && x === 10) {
      break labelCancelLoops;
    } else if (z === 10) {
      break;
    }
  }
}
```

### `continue` statement

The `continue` statement can be used to restart a `while`, `do-while`, `for`, or `label` statement.

When you use `continue` without a label, it terminates the current iteration of the innermost enclosing `while`, `do-while`, or `for` statement and continues execution of the loop with the next iteration. In contrast to the `break` statement, `continue` does not terminate the execution of the loop entirely. In a `while` loop, it jumps back to the condition. In a `for` loop, it jumps to the increment-expression. When you use `continue` with a label, it applies to the looping statement identified with that label.

The syntax of the `continue` statement looks like the following:

continue;
continue label;


**Example 1:**

The following example shows a `while` loop with a `continue` statement that executes when the value of `i` is 3. Thus, `n` takes on the values 1, 3, 7, and 12.

let i = 0;
let n = 0;
while (i < 5) {
  i++;
  if (i === 3) {
    continue;
  }
  n += i;
  console.log(n);
}
// Logs:
// 1 3 7 12

// If you comment out the continue;, the loop would run till the end and you would see 1, 3, 6, 10, 15.
```

**Example 2:**

A statement labeled `checkiandj` contains a statement labeled `checkj`. If `continue` is encountered, the program terminates the current iteration of `checkj` and begins the next iteration. Each time `continue` is encountered, `checkj` reiterates until its condition returns false. When false is returned, the remainder of the `checkiandj` statement is completed, and `checkiandj` reiterates until its condition returns false. When false is returned, the program continues at the statement following `checkiandj`.

If `continue` had a label of `checkiandj`, the program would continue at the top of the `checkiandj` statement.

let i = 0;
let j = 10;
checkiandj: while (i < 4) {
  console.log(i);
  i += 1;
  checkj: while (j > 4) {
    console.log(j);
    j -= 1;
    if (j % 2 === 0) {
      continue checkj;
    }
    console.log(j, "is odd.");
  }
  console.log("i =", i);
  console.log("j =", j);
}
```

### `for...in` statement

The `for...in` statement iterates a specified variable over all the enumerable properties of an object. For each distinct property, JavaScript executes the specified statements. A `for...in` statement looks as follows:

for (variable in object) {
  statement
}

**Example:**

The following function takes as its argument an object and the object's name. It then iterates over all the object's properties and returns a string that lists the property names and their values.

function dumpProps(obj, objName) {
  let result = "";
  for (const i in obj) {
    result += `${objName}.${i} = ${obj[i]}<br>`;
  }
  result += "<hr>";
  return result;
}

// For an object car with properties make and model, result would be:
// car.make = Ford
// car.model = Mustang
```

**Arrays:**

Although it may be tempting to use this as a way to iterate over Array elements, the `for...in` statement will return the name of your user-defined properties in addition to the numeric indexes. Therefore, it is better to use a traditional `for` loop with a numeric index when iterating over arrays because the `for...in` statement iterates over user-defined properties in addition to the array elements if you modify the Array object (such as adding custom properties or methods).

### `for...of` statement

The `for...of` statement creates a loop iterating over iterable objects (including Array, Map, Set, arguments object, and so on), invoking a custom iteration hook with statements to be executed for the value of each distinct property.

for (variable of object) {
  statement
}


The following example shows the difference between a `for...of` loop and a `for...in` loop. While `for...in` iterates over property names, `for...of` iterates over property values:

const arr = [3, 5, 7];
arr.foo = "hello";

for (const i in arr) {
  console.log(i);
}
// "0" "1" "2" "foo"

for (const i of arr) {
  console.log(i);
}
// Logs: 3 5 7

The `for...of` and `for...in` statements can also be used with destructuring. For example, you can simultaneously loop over the keys and values of an object using `Object.entries()`.

const obj = { foo: 1, bar: 2 };

for (const [key, val] of Object.entries(obj)) {
  console.log(key, val);
}
// "foo" 1
// "bar" 2

Certainly! Here's the modified and more readable text:

      text
**Block statement**

The most basic statement is a block statement, used to group statements. The block is delimited by a pair of curly braces:

      
{
  statement1;
  statement2;
  // …
  statementN;
}
   

**Example:**

Block statements are commonly used with control flow statements (if, for, while).

      
while (x < 10) {
  x++;
}
   

Here, `{ x++; }` is the block statement.

Note: var-declared variables are not block-scoped, but are scoped to the containing function or script, and the effects of setting them persist beyond the block itself.

**Example:**

      
var x = 1;
{
  var x = 2;
}
console.log(x); // 2
   

This outputs 2 because the var `x` statement within the block is in the same scope as the var `x` statement before the block. (In C or Java, the equivalent code would have output 1.) This scoping effect can be mitigated by using let or const.

**Conditional statements**

A conditional statement executes if a specified condition is true.     supports two conditional statements: if...else and switch.

**if...else statement**

Use the if statement to execute a statement if a logical condition is true. Use the optional else clause to execute a statement if the condition is false.

An if statement looks like this:

      
if (condition) {
  statement1;
} else {
  statement2;
}
   

The condition can be any expression that evaluates to true or false. If condition evaluates to true, statement1 is executed. Otherwise, statement2 is executed. statement1 and statement2 can be any statement, including further nested if statements.

You can also compound the statements using else if to have multiple conditions tested in sequence:

      
if (condition1) {
  statement1;
} else if (condition2) {
  statement2;
} else if (conditionN) {
  statementN;
} else {
  statementLast;
}
   

In the case of multiple conditions, only the first logical condition which evaluates to true will be executed. To execute multiple statements, group them within a block statement (`{ /* … */ }`).

Best practice: It's good practice to always use block statements, especially when nesting if statements:

      
if (condition) {
  // Statements for when condition is true
  // …
} else {
  // Statements for when condition is false
  // …
}
   

In general, avoid an if...else with an assignment like `x = y` as a condition:

      
if (x = y) {
  // statements here
}
   

However, in the rare case you find yourself wanting to do something like that, the while documentation has a "Using an assignment as a condition" section with guidance on a general best-practice syntax you should know about and follow.

**Falsy values**

The following values evaluate to false (also known as Falsy values):

- false
- undefined
- null
- 0
- NaN
- the empty string ("")

All other values, including all objects, evaluate to true when passed to a conditional statement.

Note: Do not confuse the primitive boolean values true and false with the true and false values of the Boolean object!

For example:

      
const b = new Boolean(false);
if (b) {
  // this condition evaluates to true
}
if (b == true) {
  // this condition evaluates to false
}
   

**Example:**

In the following example, the function `checkData` returns true if the number of characters in a Text object is three. Otherwise, it displays an alert and returns false.

      
function checkData() {
  if (document.form1.threeChar.value.length === 3) {
    return true;
  } else {
    alert(`Enter exactly three characters. ${document.form1.threeChar.value} is not valid.`);
    return false;
  }
}
   

**switch statement**

A switch statement allows a program to evaluate an expression and attempt to match the expression's value to a case label. If a match is found, the program executes the associated statement.

A switch statement looks like this:

      
switch (expression) {
  case label1:
    statements1;
    break;
  case label2:
    statements2;
    break;
  // …
  default:
    statementsDefault;
}
   

    evaluates the switch statement as follows:

1. The program first looks for a case clause with a label matching the value of expression and then transfers control to that clause, executing the associated statements.
2. If no matching label is found, the program looks for the optional default clause:
   - If a default clause is found, the program transfers control to that clause, executing the associated statements.
   - If no default clause is found, the program resumes execution at the statement following the end of switch. (By convention, the default clause is written as the last clause, but it does not need to be so.)

**break statements**

The optional break statement associated with each case clause ensures that the program breaks out of switch once the matched statement is executed, and then continues execution at the statement following switch. If break is omitted, the program continues execution inside the switch statement (and will execute statements under the next case, and so on).

**Example:**

In the following example, if `fruitType` evaluates to 'Bananas', the program matches the value with case 'Bananas' and executes the associated statement. When break is encountered, the program exits the switch and continues execution from the statement following switch. If break were omitted, the statement for case 'Cherries' would also be executed.

      
switch (fruitType) {
  case "Oranges":
    console.log("Oranges are $0.59 a pound.");
    break;
  case "Apples":
    console.log("Apples are $0.32 a pound.");
    break;
  case "Bananas":
    console.log("Bananas are $0.48 a pound.");
    break;
  case "Cherries":
    console.log("Cherries are $3.00 a pound.");
    break;
  case "Mangoes":
    console.log("Mangoes are $0.56 a pound.");
    break;
  case "Papayas":
    console.log("Mangoes and papayas are $2.79 a pound.");
    break;
  default:
    console.log(`Sorry, we are out of ${fruitType}.`);
}
console.log("Is there anything else you'd like?");
   

**Exception handling statements**

You can throw exceptions using the throw statement and handle them using the try...catch statements.

**throw statement**

Use the throw statement to throw an exception. A throw statement specifies the value to be thrown:

      
throw expression;
   

You may throw any expression, not just expressions of a specific type. The following code throws several exceptions of varying types:

      
throw "Error2"; // String type
throw 42; // Number type
throw true; // Boolean type
throw {
  toString() {
    return "I'm an object!";
  }
};
   

**try...catch statement**

The try...catch statement marks

 a block of statements to try, and specifies one or more responses should an exception be thrown. If an exception is thrown, the try...catch statement catches it.

The try...catch statement consists of a try block, which contains one or more statements, and a catch block, containing statements that specify what to do if an exception is thrown in the try block.

In other words, you want the try block to succeed, but if it does not, you want control to pass to the catch block. If any statement within the try block (or in a function called from within the try block) throws an exception, control immediately shifts to the catch block. If no exception is thrown in the try block, the catch block is skipped. The finally block executes after the try and catch blocks execute but before the statements following the try...catch statement.

The following example uses a try...catch statement. The example calls a function that retrieves a month name from an array based on the value passed to the function. If the value does not correspond to a month number (1 – 12), an exception is thrown with the value 'InvalidMonthNo' and the statements in the catch block set the `monthName` variable to 'unknown'.

      
function getMonthName(mo) {
  mo--; // Adjust month number for array index (so that 0 = Jan, 11 = Dec)
  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  if (months[mo]) {
    return months[mo];
  } else {
    throw new Error("InvalidMonthNo"); // throw keyword is used here
  }
}

try {
  // statements to try
  monthName = getMonthName(myMonth); // function could throw exception
} catch (e) {
  monthName = "unknown";
  logMyErrors(e); // pass exception object to error handler (i.e. your own function)
}
   

**The catch block**

You can use a catch block to handle all exceptions that may be generated in the try block.

      
catch (exception) {
  statements;
}
   

The catch block specifies an identifier (exception in the preceding syntax) that holds the value specified by the throw statement. You can use this identifier to get information about the exception that was thrown.

    creates this identifier when the catch block is entered. The identifier lasts only for the duration of the catch block. Once the catch block finishes executing, the identifier no longer exists.

For example, the following code throws an exception. When the exception occurs, control transfers to the catch block.

      
try {
  throw "myException"; // generates an exception
} catch (err) {
  // statements to handle any exceptions
  logMyErrors(err); // pass exception object to error handler
}
   

Note: When logging errors to the console inside a catch block, using `console.error()` rather than `console.log()` is advised for debugging. It formats the message as an error and adds it to the list of error messages generated by the page.

**The finally block**

The finally block contains statements to be executed after the try and catch blocks execute. Additionally, the finally block executes before the code that follows the try…catch…finally statement.

It is also important to note that the finally block will execute whether or not an exception is thrown. If an exception is thrown, however, the statements in the finally block execute even if no catch block handles the exception that was thrown.

You can use the finally block to make your script fail gracefully when an exception occurs. For example, you may need to release a resource that your script has tied up.

The following example opens a file and then executes statements that use the file. (Server-side     allows you to access files.) If an exception is thrown while the file is open, the finally block closes the file before the script fails. Using finally here ensures that the file is never left open, even if an error occurs.

      
openMyFile();
try {
  writeMyFile(theData); // This may throw an error
} catch (e) {
  handleError(e); // If an error occurred, handle it
} finally {
  closeMyFile(); // Always close the resource
}
   

If the finally block returns a value, this value becomes the return value of the entire try…catch…finally production, regardless of any return statements in the try and catch blocks:

      
function f() {
  try {
    console.log(0);
    throw "bogus";
  } catch (e) {
    console.log(1);
    // This return statement is suspended until finally block has completed
    return true;
    console.log(2); // not reachable
  } finally {
    console.log(3);
    return false; // overwrites the previous "return"
    console.log(4); // not reachable
  }
  // "return false" is executed now
  console.log(5); // not reachable
}
console.log(f()); // 0, 1, 3, false
   

Overwriting of return values by the finally block also applies to exceptions thrown or re-thrown inside of the catch block:

      
function f() {
  try {
    throw "bogus";
  } catch (e) {
    console.log('caught inner "bogus"');
    // This throw statement is suspended until
    // finally block has completed
    throw e;
  } finally {
    return false; // overwrites the previous "throw"
  }
  // "return false" is executed now
}

try {
  console.log(f());
} catch (e) {
  // this is never reached!
  // while f() executes, the `finally` block returns false,
  // which overwrites the `throw` inside the above `catch`
  console.log('caught outer "bogus"');
}
// Logs:
// caught inner "bogus"
// false

**Nesting try...catch statements**

You can nest one or more try...catch statements.

If an inner try block does not have a corresponding catch block:

- it must contain a finally block, and
- the enclosing try...catch statement's catch block is checked for a match.

For more information, see nested try-blocks on the try...catch reference page.

**Utilizing Error objects**

Depending on the type of error, you may be able to use the name and message properties to get a more refined message.

The name property provides the general class of Error (such as DOMException or Error), while message generally provides a more succinct message than one would get by converting the error object to a string.

If you are throwing your own exceptions, in order to take advantage of these properties (such as if your catch block doesn't discriminate between your own exceptions and system ones), you can use the Error constructor.

For example:

      
function doSomethingErrorProne() {
  if (ourCodeMakesAMistake()) {
    throw new Error("The message");
  } else {
    doSomethingToGetA   Error();
  }
}

try {
  doSomethingErrorProne();
} catch (e) {
  // Now, we actually use `console.error()`
  console.error(e.name); // 'Error'
  console.error(e.message); // 'The message',
 or a error message
}
   
   

name   newText
Functions are one of the fundamental building blocks in JavaScript. A function in JavaScript is similar to a procedure—a set of statements that performs a task or calculates a value, but for a procedure to qualify as a function, it should take some input and return an output where there is some obvious relationship between the input and the output. To use a function, you must define it somewhere in the scope from which you wish to call it. Defining functions
Function declarations
A function definition (also called a function declaration, or function statement) consists of the function keyword, followed by:
The name of the function.
A list of parameters to the function, enclosed in parentheses and separated by commas.
The JavaScript statements that define the function, enclosed in curly braces, { /* … */ }.
For example, the following code defines a simple function named square:

JS

function square(number) {
  return number * number;
}

The function square takes one parameter, called number. The function consists of one statement that says to return the parameter of the function (that is, number) multiplied by itself. The return statement specifies the value returned by the function, which is number * number.
Parameters are essentially passed to functions by value — so if the code within the body of a function assigns a completely new value to a parameter that was passed to the function, the change is not reflected globally or in the code which called that function.
When you pass an object as a parameter, if the function changes the object's properties, that change is visible outside the function, as shown in the following example:

JS

function myFunc(theObject) {
  theObject.make = "Toyota";
}

const mycar = {
  make: "Honda",
  model: "Accord",
  year: 1998,
};

console.log(mycar.make); // "Honda"
myFunc(mycar);
console.log(mycar.make); // "Toyota"

When you pass an array as a parameter, if the function changes any of the array's values, that change is visible outside the function, as shown in the following example:

JS

function myFunc(theArr) {
  theArr[0] = 30;
}

const arr = [45];

console.log(arr[0]); // 45
myFunc(arr);
console.log(arr[0]); // 30
Function expressions
While the function declaration above is syntactically a statement, functions can also be created by a function expression. Such a function can be anonymous; it does not have to have a name. For example, the function square could have been defined as:

JS

const square = function (number) {
  return number * number;
};

console.log(square(4)); // 16

However, a name can be provided with a function expression. Providing a name allows the function to refer to itself, and also makes it easier to identify the function in a debugger's stack traces:

JS

const factorial = function fac(n) {
  return n < 2 ? 1 : n * fac(n - 1);
};

console.log(factorial(3)); // 6

Function expressions are convenient when passing a function as an argument to another function. The following example shows a map function that should receive a function as first argument and an array as second argument:

JS

function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

In the following code, the function receives a function defined by a function expression and executes it for every element of the array received as a second argument:

JS

function map(f, a) {
  const result = new Array(a.length);
  for (let i = 0; i < a.length; i++) {
    result[i] = f(a[i]);
  }
  return result;
}

const cube = function (x) {
  return x * x * x;
};

const numbers = [0, 1, 2, 5, 10];
console.log(map(cube, numbers)); // [0, 1, 8, 125, 1000]

In JavaScript, a function can be defined based on a condition. For example, the following function definition defines myFunc only if num equals 0:

JS

let myFunc;
if (num === 0) {
  myFunc = function (theObject) {
    theObject.make = "Toyota";
  };
}

In addition to defining functions as described here, you can also use the Function constructor to create functions from a string at runtime, much like eval(). A method is a function that is a property of an object. Read more about objects and methods in Working with objects.
Calling functions
Defining a function does not execute it. Defining it names the function and specifies what to do when the function is called. Calling the function actually performs the specified actions with the indicated parameters. For example, if you define the function square, you could call it as follows:

JS

square(5);

The preceding statement calls the function with an argument of 5. The function executes its statements and returns the value 25. Functions must be in scope when they are called, but the function declaration can be hoisted (appear below the call in the code). The scope of a function declaration is the function in which it is declared (or the entire program, if it is declared at the top level).
The arguments of a function are not limited to strings and numbers. You can pass whole objects to a function. The showProps() function (defined in Working with objects) is an example of a function that takes an object as an argument. A function can call itself. For example, here is a function that computes factorials recursively:

JS

function factorial(n) {
  if (n === 0 || n === 1) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}

You could then compute the factorials of 1 through 5 as follows:

JS

console.log(factorial(1)); // 1
console.log(factorial(2)); // 2
console.log(factorial(3)); // 6
console.log(factorial(4)); // 24
console.log(factorial(5)); // 120

There are other ways to call functions. There are often cases where a function needs to be called dynamically, or the number of arguments to a function vary, or in which the context of the function call needs to be set to a specific object determined at runtime. It turns out that functions are themselves objects — and in turn, these objects have methods. (See the Function object.) The call() and apply() methods can be used to achieve this goal.
Function hoisting
Consider the example below:

JS

console.log(square(5)); // 25

function square(n) {
  return n * n;
}

This code runs without any error, despite the square() function being called before it's declared. This is because the JavaScript interpreter hoists the entire function declaration to the top of the scope before executing any part of the code. This means that you can call the function before it appears in the code, and it will work as expected.
Function scope
Variables declared inside a function are not accessible from outside the function. For example:

JS

function myFunction() {
  const a = 4;
  return a * a;
}

console.log(a); // ReferenceError: a is not defined

The variable a is only accessible within the block or scope of the function myFunction().
However, a function can access all variables and functions defined inside the scope in which it is defined. In other words, a function defined in the global scope can access all variables defined in the global scope. A function defined inside another function can also access all variables defined in its parent function and any other variable to which the parent function has access.
Function closures
A closure is the combination of a function and the lexical environment within which that function was declared. This environment consists of any local variables that were in scope at the time the closure was created. A closure allows a function to access those outer variables even when the function is invoked outside their scope. In JavaScript, closures are created every time a function is created, at function creation time.
Here is an example:

JS

function init() {
  const name = "Mozilla"; // name is a local variable created by init
  function displayName() {
    // displayName() is the inner function, a closure
    console.log(name); // use variable declared in the parent function
  }
  displayName();
}

init();

init() creates a local variable called name and a function called displayName(). The displayName() function is an inner function that is defined inside init() and is only available within the body of the init() function. Note that the displayName() function has access to the name variable declared in the parent function.
init() is invoked, causing the displayName() function to be executed, outputting "Mozilla" to the console. However, if we try to access the name variable outside the init() function, it is undefined:

JS

function init() {
  const name = "Mozilla"; // name is a local variable created by init
  function displayName() {
    // displayName() is the inner function, a closure
    console.log(name); // use variable declared in the parent function
  }
  return displayName;
}

const myFunc = init();
myFunc();

In this example, the init() function returns the displayName() function. This returned function is assigned to the variable myFunc, and then myFunc is invoked. Even though the init() function has finished executing, the name variable is still accessible by the displayName() function, which is now a closure.
Passing functions as values
JavaScript functions are first-class objects, which means they can be:
Stored in variables, object properties, or array elements
Passed as arguments to functions
Returned as values from functions
This opens up interesting possibilities for writing flexible and reusable code. For example, you can store a function in a variable, pass it as an argument to another function, and then call it later. Here's a simple example:

JS

function sayHello(name) {
  return `Hello, ${name}!`;
}

const greet = sayHello;
console.log(greet("John")); // "Hello, John!"

In this example, sayHello is a function that takes a name as a parameter and returns a greeting string. The greet variable is then assigned the sayHello function, and we can use greet as if it were the original sayHello function.
You can also pass a function as an argument to another function. Consider the following example:

JS

function greetSomeone(greeterFunc, name) {
  return greeterFunc(name);
}

const result = greetSomeone(sayHello, "Alice");
console.log(result); // "Hello, Alice!"

In this case, greetSomeone is a function that takes two arguments: greeterFunc (a function) and name. It calls the greeterFunc function, passing the name as an argument, and returns the result. When we call greetSomeone with sayHello as the greeterFunc and "Alice" as the name, it effectively calls sayHello("Alice") and returns the greeting.
Returning functions from functions
A function can also return another function. This is particularly useful for creating functions with specialized behavior. Here's an example:

JS

function multiplier(factor) {
  return function (number) {
    return number * factor;
  };
}

const multiplyByTwo = multiplier(2);
console.log(multiplyByTwo(5)); // 10

const multiplyByTen = multiplier(10);
console.log(multiplyByTen(5)); // 50

In this example, the multiplier function takes a factor as an argument and returns a new function. The returned function takes a number as an argument and multiplies it by the factor provided to the outer function. This allows us to create new functions, such as multiplyByTwo and multiplyByTen, with specific multiplication behavior.
Arrow functions
ES6 introduced arrow functions, which provide a concise syntax for writing anonymous functions. Arrow functions are often used for short, simple functions. Here's the basic syntax:

JS

const add = (a, b) => a + b;

console.log(add(2, 3)); // 5

In this example, add is a function that takes two parameters (a and b) and returns their sum. The arrow function syntax makes it clear and concise.
Arrow functions also have a shorter syntax when there's only one parameter and a single expression in the function body:

JS

const square = (x) => x * x;

console.log(square(4)); // 16

If there's only one parameter, the parentheses around the parameter can be omitted:

JS

const cube = x => x * x * x;

console.log(cube(3)); // 27

When the function body consists of more than one statement, you'll need to use curly braces and explicitly use the return keyword:

JS

const multiply = (a, b) => {
  const result = a * b;
  return result;
};

console.log(multiply(2, 4)); // 8

Arrow functions have lexical scoping for the this keyword, which means they inherit the this value from their surrounding scope. This behavior is different from regular functions that have their own this value. The use of arrow functions can be especially beneficial when working with callbacks and promises.
Generator functions
Generator functions are a special kind of function introduced in ES6. They allow you to pause the execution of a function and later resume it. When a generator function is called, it doesn't run its code immediately; instead, it returns an iterator called a generator object. The generator object can be used to control the execution of the generator function.
Here's an example of a simple generator function:

JS

function* countGenerator() {
  let count = 0;
  while (true) {
    yield count++;
  }
}

const counter = countGenerator();

console.log(counter.next().value); // 0
console.log(counter.next().value); // 1
console.log(counter.next().value); // 2

In this example, countGenerator is a generator function that yields an incremented count each time it's called. The counter object is an iterator for this generator, and each call to counter.next() returns an object with a value property representing the yielded value.
Generators are useful for creating iterators, asynchronous programming, and managing state over multiple function calls. They provide a way to pause and resume the execution of a function, allowing for more fine-grained control.
Async functions
Async functions are a feature introduced in ES2017 (ES8) to simplify asynchronous code using promises. An async function always returns a promise, and the await keyword can be used inside the function to wait for the resolution of a promise. This makes it easier to write and reason about asynchronous code.
Here's a basic example of an async function:

JS

function resolveAfter2Seconds() {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve("resolved");
    }, 2000);
  });
}

async function asyncCall() {
  console.log("calling");
  const result = await resolveAfter2Seconds();
  console.log(result);
  // expected output: "resolved"
}

asyncCall();

In this example, resolveAfter2Seconds is a function that returns a promise, resolving after 2000 milliseconds. The asyncCall function demonstrates the use of async and await to work with promises in a more synchronous-like manner. When await is used, it pauses the execution of the async function until the promise is resolved, allowing other asynchronous tasks to execute in the meantime.
JavaScript Standard Library
JavaScript provides a standard library, also known as the ECMAScript standard library, that includes a variety of built-in objects and functions for common tasks. These objects and functions are available in all JavaScript environments that adhere to the ECMAScript standard.
Some of the key components of the JavaScript standard library include:
Global objects: Objects that are available globally and include fundamental features, such as Object, Array, Function, and Date.
Math object: An object that provides mathematical functions and constants.
String object: An object that provides methods for working with strings.
Array object: An object that provides methods for working with arrays.
Date object: An object that represents dates and times, with methods for manipulation.
JSON object: An object that provides methods for working with JSON data.
RegExp object: An object that represents regular expressions for pattern matching.
Error objects: Objects that represent errors, with properties like name and message.
In addition to these, there are many other objects and functions provided by the standard library. Understanding the standard library is crucial for effective JavaScript development. Let's look at a few examples:

Global objects:

JS

const myObject = {
  key: "value",
};

const keys = Object.keys(myObject);
console.log(keys); // ["key"]

The Object.keys() function is part of the Object global object and is used to retrieve the keys of an object.

Math object:

JS

const randomNumber = Math.random();
console.log(randomNumber);

The Math.random() function returns a floating-point, pseudo-random number in the range from 0 (inclusive) to 1 (exclusive).

String object:

JS

const myString = "Hello, World!";
console.log(myString.length); // 13

The length property of the String object is used to get the length of a string.

Array object:

JS

const myArray = [1, 2, 3, 4, 5];
const doubledArray = myArray.map((num) => num * 2);
console.log(doubledArray); // [2, 4, 6, 8, 10]

The map() function is part of the Array global object and is used to create a new array with the results of calling a provided function on every element in the array.

Date object:

JS

const currentDate = new Date();
console.log(currentDate.getFullYear()); // current year

The Date object is used for working with dates and times. In this example, getFullYear() retrieves the current year.

JSON object:

JS

const jsonData = '{"name":"John","age":30}';
const parsedData = JSON.parse(jsonData);
console.log(parsedData.name); // John

The JSON.parse() function is part of the JSON global object and is used to parse a JSON string, producing a JavaScript object.

RegExp object:

JS

const pattern = /\d+/;
const result = pattern.test("123abc");
console.log(result); // true

The RegExp object is used for working with regular expressions. In this example, the test() method checks if the string contains one or more digits.

Error objects:

JS

try {
  // code that may throw an error
  throw new Error("This is an error");
} catch (error) {
  console.error(error.message);
}

The Error object is used for representing and handling errors. In this example, an error is thrown and caught, and its message is logged.

By staying informed, adopting best practices, and using modern tools and frameworks, developers can create efficient, scalable, and maintainable JavaScript applications. JavaScript's versatility, coupled with a vibrant ecosystem, makes it a powerful language for building a wide range of web applications and services.



